## プロセスとファイル入出力

さて、前回、プロセスというのは「自分が独占したメモリーの中で動いているので、その中で何をしても他のプロセスのメモリーに影響を与えない」というのを見れたかと思います。でも、そんな自分の中だけで完結してる引きこもりみたいなプロセスじゃあ、意味がないですね。外界からなんかデータをもらって、自分の中で処理して、それを外の世界に知らせる方法が必要になってきます。

そこで、プロセスに外から何かを入力したり、プロセスが外に何かを出力する方法として、「ファイルの入出力」というのがあります。たとえば、ファイルに書かれたデータをプロセスがメモリー上に読み込んでなんか処理をするとか、処理を行った結果をテキストファイルに書き込みをするとか。例を見てみましょう。

まず、以下のようなテキストファイルを nyan.txt という名前で適当な場所に作ってみます。

```
nyan
nyan nyan
nyan nyan nyan
```

では、このファイルをプロセスの中に読み込むRubyスクリプトを作ってみましょう。

```ruby
# ファイルを読み込みモード("r")で開く
file = File.open("nyan.txt","r")
# ファイルの中身を全て読み込んで配列として取得
lines = file.readlines
# ファイルを閉じる（リソースの解放）
file.close
```

ファイルを open して、その内容を lines という変数に読み込んで、最後にファイルを close しています。ファイルの中のデータはディスクに書かれたものであり、プロセスがもともとメモリー内に持っていたものではありません。このディスクに書かれた内容を

```ruby
lines = file.readlines
```

の行でlines変数に読み込むことで、プロセスの「外界」の情報を、プロセスの内部のメモリーに読み込んでいますね。

では今度は出力をしてみましょう。

```ruby
# nyan_copy.rb
# まずファイルを読み込む
file = File.open("nyan.txt","r")
lines = file.readlines  # 全行を配列として読み込み
file.close

# 今度は書き込み用のファイルを開く
file = File.open("nyan_copy.txt","w")  # "w"は書き込みモード
file.write(lines.join)  # 配列を文字列に結合して書き込み
file.close  # ファイルを閉じる
```

nyan\_copy.rbを、nyan.txtと同じディレクトリに作って、実行してみましょう。nyan.txtと同じ内容の、nyan\_copy.txtというファイルが生まれたかと思います。さきほどディスクから読み込んでメモリー上に展開したデータを、そのまま別のファイルに対して出力したためですね。

こうして、プロセスはファイルを通じて外部との入出力を行うことができます。

#### ファイル入出力から考える「入出力の本質」

ここで重要なことに気づいたでしょうか？プロセスにとって「入出力」とは：

1. **何かから情報を読み取る**（入力）
2. **何かに情報を書き出す**（出力）

という2つの基本的な操作に集約されます。さっきの例では「何か」がディスク上のファイルでしたが、この「何か」は必ずしもファイルである必要はありません。

例えば：
- キーボードから文字を読み取る
- ネットワーク経由でデータを受け取る  
- 画面に文字を表示する
- プリンターに印刷データを送る

これらすべて、プロセスから見れば「何かから読む」「何かに書く」という同じパターンの操作です。

そこでUnix系システムでは、**これらすべての入出力操作を「ファイル操作と同じ方法」で扱える**ように設計されました。つまり、ディスク上のファイルを読み書きするのと全く同じAPI（プログラミング方法）で、キーボードやディスプレイ、ネットワークなども操作できるのです。

### Unix系の「すべてがファイル」という哲学

#### 「すべてがファイル」って何？

さて、いまは「テキストファイル」への読み書きを行ってみましたが、「Linuxではすべてがファイルなんだよ」みたいな話を聞いたことがないでしょうか？ そんなこと言われても、「はっ？」って感じの話ですよね。

まず、この「すべてがファイル」という表現は確かに誤解を招きやすいです。「Linuxではキーボードもファイルだからね」みたいなことを言うひとに至っては「こいつ頭大丈夫か、キーボードはキーボードだろうが」みたいな気持ちになりますよね。わたしは最初にこの話を聞いたときに「なにそれ、禅問答？哲学？頭大丈夫？ファイルはファイルだしキーボードはキーボードだろ」って思いました。

「全てがファイル」とか言われると「世の中のすべてはファイルなのだ、そう、きみも、わたしも」みたいな禅問答をやられてるみたいな気持ちになるので、こういう言い方はあまりよくない感じがしますね。

#### より正確に言うと

「すべてがファイル」というのは、実際には「**すべての入出力が、ファイルと同じ操作方法で扱える**」という意味です。

つまり：
- ディスクからファイルを読むときの操作方法
- キーボードから入力を受け取るときの操作方法
- ネットワーク経由でデータを送受信するときの操作方法

これらが**すべて同じAPI（プログラミングインターフェース）**で操作できるように設計されているということなのです。

#### なぜこの設計が優れているのか

この統一された設計により、プログラマーは：
1. **一度覚えた操作方法**（ファイルの読み書き）で、様々な入出力を扱える
2. **同じコード**でファイル、ネットワーク、デバイスを操作できる
3. **コマンドの組み合わせ**（パイプやリダイレクト）が自然に動作する

といった恩恵を受けることができます。

### 標準入出力：ファイル操作の特別な形

「すべてがファイル」という話をしましたが、実際に体験してみる前に、まず「標準入出力」という概念について説明しましょう。

#### 「標準」って何が標準なの？  

プログラムやプロセスが動くとき、普通は以下の3つの「入出力の口」が**標準的に**用意されています：

1. **標準入力（Standard Input, stdin）**：プログラムがデータを受け取るための入り口
2. **標準出力（Standard Output, stdout）**：プログラムが結果を出すための出口
3. **標準エラー出力（Standard Error, stderr）**：プログラムがエラーメッセージを出すための出口

なぜ「標準」と呼ばれるかというと、**どんなプログラムでも最初からこの3つの口が自動的に用意されている**からです。プログラマーが特別な準備をしなくても、すぐに使える「標準装備」みたいなものですね。

#### ターミナルがデフォルトの相手

プログラムを実行すると、これらの標準入出力は**デフォルトでターミナル（あなたが使っているコマンドライン画面）**につながっています：

- 標準入力 → キーボードから入力を受け取る
- 標準出力 → ターミナル画面に文字を表示する  
- 標準エラー出力 → ターミナル画面にエラーを表示する

つまり、普段あなたがターミナルでプログラムを実行して文字が表示されるのは、プログラムが「標準出力」に文字を送り、それがターミナル画面に表示されているからなのです。

#### ファイル操作と標準入出力の関係

ここで重要なのは、この標準入出力も**ファイルと全く同じ方法で操作できる**ということです。さっきファイルに対して行った`File.open`、`readlines`、`write`、`close`といった操作が、標準入出力に対してもそのまま使えるのです。

では、実際に例を見てみましょう。

```ruby
# stdout.rb
# ファイルの内容を読み込む
file = File.open("nyan.txt","r")
lines = file.readlines
file.close

# $stdout：標準出力（通常はターミナル）を表すグローバル変数
file = $stdout # この行だけ書き換えた
file.write(lines.join)  # 標準出力（ターミナル）に書き込み
file.close
```

nyan.txt と同じディレクトリに、今度は stdout.rb を作って、実行してみましょう。nyan.txtの内容が、ターミナルに出力されたかと思います。

Rubyの組み込みグローバル変数`$stdout`には、「標準出力」と言われるものが、**すでにFile.openされた状態で**入っています。重要なのは、この標準出力も**ファイルと全く同じオブジェクト**として扱えることです。

つまり：
- さっきは `File.open("nyan_copy.txt", "w")` でファイルを開いて書き込んだ
- 今度は `$stdout` という「すでに開かれているファイル」に書き込んでいる
- 操作方法（`write`メソッドの使い方）は全く同じ

この「標準出力」の出力先は、デフォルトではターミナルを指します。そのため、さっきテキストファイルに内容を出力したのと**全く同じやり方**で、ターミナルに対して出力ができるわけです。

これが「すべてがファイル」の実際の意味です。ファイルもターミナルも、プログラムから見れば同じ操作で扱える「入出力先」なのです。

#### 標準入力も同じ仕組み

標準出力があるなら標準入力もあるの？当然あります。Rubyだと標準入力も**File.openされた状態で**`$stdin`というグローバル変数に入っています。

ここでも重要なのは、標準入力も**ファイルと全く同じオブジェクト**として扱えることです：
- さっきは `File.open("nyan.txt", "r")` でファイルを開いて読み込んだ
- 今度は `$stdin` という「すでに開かれているファイル」から読み込む
- 操作方法（`readlines`メソッドの使い方）は全く同じ

標準入力のデフォルトの入力ソースは**ターミナル**（つまりあなたのキーボード入力）になります。例を見ましょう。

```ruby
# stdin.rb
# $stdin：標準入力（通常はキーボード）を表すグローバル変数
file = $stdin
# EOFが入力されるまで全ての入力を受け取る（ここでブロック）
lines = file.readlines
file.close

# 受け取った内容をそのまま標準出力に書き出す
file = $stdout
file.write(lines.join)  # エコープログラムの動作
file.close
```

上記のような stdin.rb というファイルを作成して、実行してみましょう。何も出力されず、かつプロンプトも返ってこない状態になると思います。これはなぜかと言うと、

```ruby
lines = file.readlines #標準入力からの入力を全部受け取る
```

の行で、プロセスが「ブロック中」になっているからです。前回の内容を思い出してください。プロセスの実行中の状態のうちの一つに、「ブロック中」があったと思いますが、ブロック中というのは、「IOとかを待ってて今は処理できないよ」という状態でしたね。

#### なぜファイルと標準入力で違いがあるの？

ここで重要な違いがあります：

- **ファイル**：すでに内容が決まっていて、「ここまでがファイルの内容」という終わりがはっきりしている
- **標準入力（ターミナル）**：あなたがこれから入力する内容なので、「いつ終わるか」がプログラムにはわからない

この行では、標準入力からの入力を「全部」読み込もうとしています。そして、標準入力のデフォルトはターミナル（キーボード）からの読み込みを行います。

しかし、すでに何が書かれているか決まっているディスク上のファイルと違って、ターミナルへの入力は「終わり」がいつ来るものなのかわかりません。だから、このプロセスは「終わり」が入力されるまで、ずっとずっと「ブロック中」の状態で待ち続けているのです。けなげですね。

では、ひとまず以下のような感じで、プロンプトが戻ってきてないターミナルに何かを打ち込んでみてください。

```shell
$ ruby stdin.rb #さっき実行したコマンド
aaaa
bbbbbb
ccc
```

打ち込みましたか？そうしたら、改行したあと、おもむろにCtrlキーを押しながらDを押してみましょう。すると、ターミナルに、あたらしく

```
aaaa
bbbbbb
ccc
```

と、さっき自分で入力したのと同じ内容が出力されるはずです。

Ctrl+D を押すと、**EOF**というものが入力されます。この「EOF」というのは「**End Of File**」の略で、「ここでこのファイル（この場合は標準入力）はおしまいだよ」というのを伝える特別な信号です。

プロセスは、この「EOF」を受け取ることで、「よし、標準入力を全部読み込んだぞ」と理解して、IO待ちのブロック状態から抜けるわけですね。

#### プロセスと標準入出力の関係

ここまで見てきたように、**どのプロセスも生まれた時から標準入出力という3つの「口」を持っている**ことがわかります。これらの口は：

1. **デフォルトではターミナルにつながっている**
2. **ファイルと全く同じ方法で操作できる**
3. **プロセスが終了するまで自動的に管理されている**

つまり、プロセスから見ると「ファイルを読み書きするのも、ターミナルとやり取りするのも、全く同じ操作」なのです。

ところで、最初の例では標準入力ではなくてnyan.txtを読み込んでいましたが、実はその間にも、一瞬プロセスは「ブロック中」状態になっています。ディスクからデータを読みこんでくるのが一瞬なので、普段はあまり意識しないかもしれませんが(とはいえ、コンピューターの処理の中ではdiskIOというのはかなり遅い処理の部類です。だから、パフォーマンスが必要になってくるようなソフトウェアを書くときには、なるべくIOをしないことでブロックされないようにしてパフォーマンスを稼ぐみたいな手法が取られたりするわけです)。

こんな感じで、「実際はディスク上のファイルじゃないもの」（ターミナル、キーボード、ネットワーク接続など）も、「ディスク上のファイルと全く同じように」扱える。そういう統一的な仕組みがLinuxには備わっています。

**これが「すべてがファイル」の本当の意味**です：
- キーボードが「ファイル」になるわけではない
- でも、キーボードからの入力を「ファイルを読むのと同じ操作」で受け取れる
- つまり、プログラマーは一つの操作方法を覚えるだけで、様々な入出力を扱える

この設計により、後で説明する「リダイレクト」や「パイプ」といった強力な機能が自然に動作するのです。

ちなみに、標準入力/出力の他にも、「標準エラー出力」というのがあり、これもデフォルトの出力先はターミナルになっています。

余談ですが、IO#readlinesは「ファイルの内容を全部読み込む」という挙動をしますが、では一行だけ読み込む IO#readline を使うとどういう挙動をするかなど、自分で確かめてみると、「あっブロックしてる」「あっ今読み込んでブロック中じゃなくなった」みたいなのがわかっておもしろいかもしれません。

### 標準入出力の「つなぎ先」を変更する

先ほどから標準入出力の「デフォルト」はどうこうみたいな話をしていますが、それはつまり**標準入出力は他の場所にもつなげられる**ってことですね。

これまでの説明をまとめると：
- プロセスは生まれた時から標準入出力という「3つの口」を持っている
- デフォルトではこの3つの口は「ターミナル」につながっている  
- でも、これらの口は「他の場所」にもつなぎ直すことができる

例えば：
- 標準入力を「ファイル」につなぐ → ファイルの内容がプログラムに入力される
- 標準出力を「ファイル」につなぐ → プログラムの出力がファイルに書き込まれる
- 標準出力を「別のプログラムの標準入力」につなぐ → 2つのプログラムが連携動作する

このような「つなぎ先の変更」を実現するための機能が「リダイレクト」と「パイプ」です。

### リダイレクト：標準入出力の「つなぎ先」を変更する

リダイレクトを使うと、標準入出力の「つなぎ先」を変更することができます。つまり、デフォルトではターミナルにつながっている標準入出力を、ファイルなどの別の場所に向けることができるのです。

#### 標準入出力の番号による表現

シェル上（sh、bash、zsh等）では、3つの標準入出力がそれぞれ数字で表されます：

- **標準入力 → 0**
- **標準出力 → 1** 
- **標準エラー出力 → 2**

なぜ数字なのかは後で説明しますが、今は「そういう決まりがある」と覚えておいてください。

#### リダイレクトの記号

出力系のリダイレクトは以下の記号で行えます：

- **`>`** ：ファイルを上書きする（ファイルが存在する場合は内容を消去して新しく書き込む）
- **`>>`** ：ファイルに追記する（ファイルが存在する場合は末尾に追加する）

入力系のリダイレクトは：

- **`<`** ：ファイルから読み込む

### 標準出力のリダイレクト
例えば、

```ruby
# print_mew.rb
# puts：標準出力に文字列を出力（自動的に改行も追加）
puts "mew"
```

というrubyスクリプトがあるとき、

```shell
$ ruby print_mew.rb 1>mew.txt
```

とすると、mew とだけ書かれた mew.txt というファイルができあがります。"1>mew.txt"が、「標準出力(1)の出力先はmew.txtだよ」を意味するわけですね。その上で

```shell
$ ruby print_mew.rb 1>>mew.txt
```

とすると、 mew.txt にさらに mew が追記され、mew.txt の中身は mew(改行)mew というものになります。"1>>mew.txt"が、「標準出力の出力先はmew.txtだよ。ファイルが存在してたら末尾に追記してね」を意味するわけです。さらにもう一度

```shell
$ ruby print_mew.rb 1>mew.txt
```

とすると、mew.txtは上書きされてしまい、「mew」とだけ書かれたファイルになります。

ちなみに、標準出力をリダイレクトする際は、「1」を省略した書き方も可能です。

```shell
$ ruby print_mew.rb > mew.txt
```

### 標準入力のリダイレクト

当然、標準入力もリダイレクトすることが可能です。そのためには、"<"という記号を使います。

試しに、さっき作った mew.txt というファイルを標準入力としてみましょう。

```shell
$ ruby stdin.rb 0<mew.txt
mew
```

"0<mew.txt"が、「mew.txtを標準入力(0)の入力ソースとするよ」を意味しているわけですね。mew.txtの内容がstdin.rbによって読み込まれ、ターミナルに書き出されたかと思います。

これも、0を省略した書き方が可能です。

```shell
$ ruby stdin.rb < mew.txt
mew
```

当然ながら、複数のリダイレクトを同時に行うことも可能です

```shell
$ ruby stdin.rb 0<mew.txt 1>mew_copy.txt
```

上記の場合、stdin.rbの標準入力はmew.txtとなり、標準出力は mew\_copy.txt となります。

stdin.rbの内容は標準入力を読み込んで標準出力にそのまま書き出すものなので、mew\_copy.txtという新しいファイルに、mew.txtの内容、つまり「mew」 が書き込まれることになります。

### 標準エラー出力のリダイレクト

標準入出力について見てみたので、標準エラー出力についても見てみましょう。

```ruby
# stdout_stderr.rb
# puts：標準出力（stdout）に出力
puts "this is stdout"
# warn：標準エラー出力（stderr）に出力
warn "this is stderr"
```

普通にstdout\_stderr.rbを実行すると、標準出力も標準エラー出力もターミナルに向いているので、どちらもターミナルに出力されます。

では、以下のようにしてみましょう。

```shell
$ ruby stdout_stderr.rb 1>out.txt 2>err.txt
```

"1>out.txt" で「標準出力(1)をout.txt」に、"2>err.txt" で「標準エラー出力(2)をerr.txt」に向けています。

すると、out.txtには "this is stdout"が、err.txt には"this is stderr"が書き出されているかと思います。

ちなみに、"2>&1"みたいにして標準エラー出力を標準出力へ向けることもできます。

```shell
$ ruby stdout_stderr.rb 1>out.txt 2>&1
```

&を付けることによって、「この1ってのは、1っていう名前のファイルじゃなくて標準出力を表す数字だよ！」ってことを言っているわけですね。さあ、またまた新しい疑問がわいてきました。なんで&付けるとそれがファイル名じゃなくて標準出力ってことになるの？ そもそもなんで0とか1とか2とかって謎っぽい数字使ってるの？ 疲れてきたので、そのあたりは次回にまわします。

### リダイレクトの順序

```shell
$ ruby stdout_stderr.rb 1>out.txt 2>&1
```

とすると、プロセス内で標準出力に書き出したものも標準エラー出力に書き出したものも out.txt に出力されます。しかし、

```shell
$ ruby stdout_stderr.rb 2>&1 1>out.txt
```

とすると、標準エラー出力に対する出力は、依然としてコンソールに出力されてしまいます。

このような動きをするのはなぜでしょうか？その説明をするためには、「ファイルディスクリプタ」というものを知る必要があります。これについては後で詳しく説明しますので、今は「そういうもんなんだな」と思っておいてください。

### パイプ

パイプについても簡単にみておきましょう。シェル上では、パイプは「|」という記号で実現されます。

```shell
$ command_a | command_b
```

とすると、command\_aの標準出力に出力された内容がcommand\_bの標準入力に入力されます。この時、command\_aの出力が全部終わってなくても(EOFに達しなくても)、command\_bのプロセスは「来たデータから順々に」処理していきます。データがcommand\_aから出力されたら、すぐにcommand\_bはそのデータを処理します。まだEOFが来てないけどcommand\_aからの出力が来ないぞ、というときにはcommand\_bはどうするでしょうか。そうですね、標準入力からのデータを読み込む部分で「ブロック中」になって、command\_aが標準出力になにかを吐くのを待ち続けるわけです。けなげですね。ちなみに、このように入力と出力をパイプでつないで、「ファイルの終わりを待たずにきたデータから順々に」なにか処理をするのを、パイプライン処理、とか、ストリーム処理、と言います。

また、パイプはシェル上でふたつのプロセスの標準入出力をつなぐだけではなく、プロセス上でも新しい入出力のペアを作ることができます。RubyだったらIO.pipeを使うと実現できるでしょう。詳しくはrubyの公式リファレンスやpipe(2)を参照してください。

### 次回予告

次回はファイルの入出力について、もっと深くまで潜っていきますよ！ファイルディスクリプタの話をして、ソケットの話をします。そのあとようやくファイルディスクリプタとforkの話ができたらいいな！さーて、次回も、サービス！サービスゥ！
